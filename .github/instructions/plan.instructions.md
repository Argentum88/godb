---
applyTo: '**'
---
### **Итоговый План Курса: "Создание High-Performance СУБД на Go с нуля"**

**Главная цель:** Разработать с нуля расширяемую, распределенную реляционную СУБД на Go, поддерживающую SQL, кастомные типы данных и индексов, cost-based оптимизатор, два вида контроля параллелизма (2PL и MVCC/SSI), репликацию и шардирование, получив при этом глубокое понимание внутреннего устройства баз данных.

---

#### **Модуль 0: Фундамент и "Hello, World"**

*   **Цель:** Заложить архитектурный каркас и получить первый работающий прототип.
*   **Занятие 0.1: Введение и настройка проекта.**
    *   **Теория:** Обзор архитектуры СУБД (Parser, Optimizer, Executor, Storage Engine).
    *   **Практика:** Настройка Go-модуля. Создание структуры каталогов (`cmd`, `internal/storage`, `internal/sql`). Написание `main.go`.
*   **Занятие 0.2: Абстракция хранилища и REPL.**
    *   **Теория:** Важность программирования через интерфейсы. Определение "контракта" для нашего движка хранения (`type Engine interface`).
    *   **Практика:** Реализация простейшего `InMemoryKV` на `map[string][]byte`. Создание REPL (Read-Eval-Print Loop) для взаимодействия с ним. Получаем первую "психологическую победу".

---

#### **Модуль 1: Менеджер Хранения (The Storage Engine)**

*   **Ключевая веха:** Научиться эффективно и гибко работать с диском.
*   **Занятие 1.1: Абстракция дискового хранилища.**
    *   **Теория:** Концепция страниц (Pages). Проектирование интерфейса `PageFile` для абстрагирования от конкретной реализации файлового хранилища (один файл, несколько файлов).
    *   **Практика:** Реализация `DiskManager` как основной реализации интерфейса `PageFile` для чтения/записи страниц в единый файл БД.
*   **Занятие 1.2: Пул буферов (Buffer Pool).**
    *   **Теория:** Кэширование страниц в памяти для минимизации I/O. "Грязные" страницы.
    *   **Практика:** Реализация `BufferPoolManager`, который работает с `PageFile` и предоставляет верхним уровням абстракцию страниц в памяти (`FetchPage`, `UnpinPage`, `FlushAllPages`).
*   **Занятие 1.3: Политики вытеснения страниц.**
    *   **Теория:** Алгоритмы LRU и Clock/Second Chance для управления кэшем.
    *   **Практика:** Реализация политики вытеснения Clock для `BufferPoolManager`.

---

#### **Модуль 2: Структура Данных на Диске**

*   **Ключевая веха:** Научиться хранить записи (кортежи) в таблицах, поддерживая расширяемые типы данных.
*   **Занятие 2.1: Страницы с записями (Slotted Pages).**
    *   **Теория:** Формат `Slotted Page` для хранения записей переменной длины.
    *   **Практика:** Реализация `Page` с методами `InsertTuple`, `GetTuple`.
*   **Занятие 2.2: Представление кортежей и типы данных.**
    *   **Теория:** Проектирование системы типов. Интерфейс `Type` (`Serialize`, `Deserialize`, `Compare`).
    *   **Практика:** Реализация базовых типов (`Integer`, `Varchar`). Структура `Tuple`, которая представляет собой набор значений (`Value`), типизированных через `Type`. При проектировании формата кортежа учесть его совместимость с MVCC (резервирование места под метаданные транзакций).
*   **Занятие 2.3: Абстракция доступа к таблице (Table Access Method).**
    *   **Теория:** `Heap File` как коллекция страниц. Важность абстракции `TableAccessMethod` для поддержки разных движков хранения (строковый vs колоночный) в будущем (HTAP).
    *   **Практика:** Определение интерфейса `TableAccessMethod`. Реализация `HeapTable` (строковое хранение) и итератора `TableIterator` для сканирования таблиц.
*   **Занятие 2.4: Системный каталог.**
    *   **Теория:** Хранение мета-информации (о таблицах, колонках, типах, индексах) внутри самой БД.
    *   **Практика:** Создание "мастер-таблиц" с помощью уже реализованного `HeapTable` для хранения схемы данных.

---

#### **Модуль 3: Индексы**

*   **Ключевая веха:** Реализовать B+Tree как один из видов индексов и заложить архитектуру для добавления новых.
*   **Занятие 3.1: Абстракция индекса.**
    *   **Теория:** Проектирование универсального интерфейса `Index` (`Insert`, `Delete`, `Scan`).
    *   **Практика:** Определение интерфейса `Index` и его интеграция с системным каталогом.
*   **Занятие 3.2: B+Tree — Структура и Поиск.**
    *   **Теория:** Структура B+Tree: внутренние и листовые узлы. Алгоритм поиска.
    *   **Практика:** Реализация `BPlusTree` (удовлетворяющего интерфейсу `Index`) и его страниц (`BPlusTreeInternalPage`, `BPlusTreeLeafPage`). Реализация метода `Search(key)` и поддержка Range Scan.
*   **Занятие 3.3: B+Tree — Вставка.**
    *   **Теория:** Алгоритм вставки. Расщепление узлов (split).
    *   **Практика:** Реализация метода `Insert(key, value)`.
*   **Занятие 3.4: B+Tree — Удаление.**
    *   **Теория:** Алгоритм удаления. Слияние (merge) и перераспределение (redistribution).
    *   **Практика:** Реализация метода `Delete(key)`.
*   **Занятие 3.5: Инвертированный индекс (Inverted Index).**
    *   **Теория:** Индексация массивов и полнотекстовый поиск. Структура инвертированного индекса.
    *   **Практика:** Добавление типа данных `Array`. Реализация инвертированного индекса для поддержки запросов "содержит элемент" или "пересекается с".

---

#### **Модуль 4: Исполнение Запросов (Query Execution)**

*   **Ключевая веха:** Заставить СУБД понимать и выполнять сложные SQL-запросы, включая различные виды соединений (JOIN).
*   **Занятие 4.1:** Парсер SQL и Векторная модель исполнения.
    *   **Теория:** Превращение SQL в AST. Модель итератора "Вулкан" vs Векторизация. Почему обработка пачками (Batch) эффективнее для CPU и кэша, и критична для аналитики (OLAP).
    *   **Практика:** Использование готового Go-пакета для парсинга SQL. Определение интерфейса `Executor` с методом `Next()`, возвращающим `TupleBatch` (а не один кортеж). Реализация `SeqScanNode`, `IndexScanNode`, `InsertNode`, `CreateTableNode`.
*   **Занятие 4.2:** Продвинутые операторы.
    *   **Теория:** Операторы `Filter` (`WHERE`), `Projection` (`SELECT a, b`), `Limit`.
    *   **Практика:** Реализация `FilterNode`, `ProjectionNode`, `LimitNode`.
*   **Занятие 4.3:** Агрегации и `GROUP BY`.
    *   **Теория:** Хеш-агрегация для вычисления `COUNT`, `SUM`, `AVG` и т.д.
    *   **Практика:** Реализация узла `HashAggregationNode`.
*   **Занятие 4.4: Простейший Join: Nested Loop Join.**
    *   **Теория:** Алгоритм вложенных циклов. Его простота и ужасающая неэффективность (O(N*M)). Случаи, когда он может быть полезен.
    *   **Практика:** Реализация `NestedLoopJoinNode`, который для каждой строки из левого дочернего узла полностью сканирует правый.
*   **Занятие 4.5: Эффективный Join: Hash Join.**
    *   **Теория:** Алгоритм хеш-соединения для экви-соединений. Фаза построения (build phase) и фаза проверки (probe phase).
    *   **Практика:** Реализация `HashJoinNode`.
*   **Занятие 4.6: Сортировка больших объемов данных: External Sorting.**
    *   **Теория:** Алгоритм внешней сортировки слиянием (External Merge Sort).
    *   **Практика:** Реализация `ExternalSortNode`.
*   **Занятие 4.7: Join для отсортированных данных: Sort-Merge Join.**
    *   **Теория:** Алгоритм соединения слиянием.
    *   **Практика:** Реализация `SortMergeJoinNode`.

---

#### **Модуль 5: Сетевой Протокол (PostgreSQL Wire Protocol)**

*   **Ключевая веха:** Научить СУБД общаться с внешним миром через стандартные драйверы PostgreSQL.
*   **Занятие 5.1: Основы протокола и Handshake.**
    *   **Теория:** Структура пакетов PG Wire Protocol. StartupMessage, Authentication.
    *   **Практика:** Реализация TCP-сервера, который принимает соединения и проходит фазу аутентификации (пустышку).
*   **Занятие 5.2: Обработка запросов (Simple Query Protocol).**
    *   **Теория:** Сообщения Query, RowDescription, DataRow, CommandComplete, ReadyForQuery.
    *   **Практика:** Интеграция с Executor. Получение SQL-запроса от клиента, выполнение, сериализация результатов в формат PG и отправка клиенту. Теперь можно подключиться через `psql`!

---

#### **Модуль 6: Оптимизатор Запросов (Query Optimization)**

*   **Ключевая веха:** Научить СУБД выбирать *эффективный* план выполнения запроса, учитывая разные типы индексов.
*   **Занятие 6.1: Сбор статистики.**
    *   **Теория:** Кардинальность, гистограммы, селективность. Зачем это нужно оптимизатору.
    *   **Практика:** Реализация команды `ANALYZE table`. Создание системных таблиц для хранения статистики.
*   **Занятие 6.2: Простой Cost-Based Optimizer.**
    *   **Теория:** Модель стоимости операторов (I/O + CPU). Сравнение стоимости `SeqScan` vs `IndexScan` для разных типов индексов на основе их свойств.
    *   **Практика:** Расширение планировщика для генерации нескольких физических планов (с использованием разных доступных индексов и видов Join) и выбора самого "дешевого" на основе собранной статистики.

---

#### **Модуль 7: Контроль Параллелизма через Блокировки (2PL)**

*   **Ключевая веха:** Реализовать ACID через классическую двухфазную блокировку.
*   **Занятие 7.1: `TransactionManager` и `LockManager`.**
    *   **Теория:** ACID. Двухфазная блокировка (2PL). Shared (S) и Exclusive (X) блокировки.
    *   **Практика:** Реализация `TransactionManager` и `LockManager`.
*   **Занятие 7.2: Уровни изоляции на блокировках.**
    *   **Теория:** Как 2PL позволяет реализовать `Read Committed` и `Repeatable Read`.
    *   **Практика:** Интеграция `LockManager` в итераторы для реализации этих уровней изоляции.
*   **Занятие 7.3: Обнаружение взаимоблокировок (Deadlock Detection).**
    *   **Теория:** Граф ожидания (`waits-for graph`). Поиск циклов. Выбор "жертвы".
    *   **Практика:** Реализация фонового процесса, который строит граф и прерывает транзакции при обнаружении deadlock.
*   **Занятие 7.4: Основы WAL (Write-Ahead Logging).**
    *   **Теория:** Принцип "сначала пишем в лог, потом на диск". Формат записи лога.
    *   **Практика:** Реализация базового `LogManager` и запись простых операций (INSERT/UPDATE) в лог перед их применением к страницам.
*   **Занятие 7.5: Восстановление после сбоев (Crash Recovery).**
    *   **Теория:** ARIES-стиль (Analysis, Redo, Undo). Чекпоинты.
    *   **Практика:** Реализация процедуры восстановления (Recovery) на основе WAL, реализованного ранее.

---

#### **Модуль 8: Продвинутый Контроль Параллелизма (MVCC)**

*   **Ключевая веха:** Реализовать современный, неблокирующий механизм контроля параллелизма.
*   **Занятие 8.1: Основы MVCC.**
    *   **Теория:** Хранение версий записей вместо перезаписи. Структура кортежа с `tx_id_create/delete`. Концепция "снимка" (snapshot).
    *   **Практика:** Модификация структуры кортежа. Реализация `TransactionManager`, управляющего ID транзакций.
*   **Занятие 8.2: Snapshot Isolation (Repeatable Read через MVCC).**
    *   **Теория:** Правила видимости версий для транзакции. Преимущество: читатели не блокируют писателей.
    *   **Практика:** Модификация итераторов для проверки видимости версий на основе "снимка" транзакции.
*   **Занятие 8.3: Serializable Snapshot Isolation (SSI).**
    *   **Теория:** Аномалия "Write Skew". Теория SSI: отслеживание конфликтов "чтение-запись" (`rw-conflicts`) для достижения полной сериализуемости.
    *   **Практика:** Добавление в `TransactionManager` структур для отслеживания чтения/записи. Реализация проверки на `rw-` конфликты при коммите.
*   **Занятие 8.4: Сборка мусора (Vacuum).**
    *   **Теория:** Необходимость удаления "мертвых" версий записей.
    *   **Практика:** Реализация фонового процесса `Vacuum` для очистки устаревших данных.

---

#### **Модуль 9: Репликация (Availability & Read Scaling)**

*   **Ключевая веха:** Обеспечить отказоустойчивость и масштабирование чтения через репликацию.
*   **Занятие 9.1: Master-Slave репликация на основе WAL.**
    *   **Теория:** Потоковая репликация (streaming replication). Синхронный vs. асинхронный режим. Позиция в логе (LSN).
    *   **Практика:** Реализация сетевого протокола для передачи записей WAL от мастера к реплике. Реплика входит в режим "восстановления" и постоянно применяет лог.
*   **Занятие 9.2: Управление репликацией и Failover.**
    *   **Теория:** Процесс "повышения" реплики до нового мастера (promotion). Концепция "кворума". Split-brain.
    *   **Практика:** Добавление команд для управления кластером (`SHOW REPLICATION STATUS`). Реализация (возможно, ручного) механизма failover.

---

#### **Модуль 10: Шардирование (Write Scaling)**

*   **Ключевая веха:** Реализовать горизонтальное масштабирование записи и хранения данных.
*   **Занятие 10.1: Архитектура шардирования.**
    *   **Теория:** Стратегии шардирования (Range-based, Hash-based). Ключ шардирования. Проблема "горячих" шардов.
    *   **Практика:** Проектирование архитектуры: узлы данных (shards), координатор/прокси (query router) и сервер метаданных (metadata server).
*   **Занятие 10.2: Координатор запросов.**
    *   **Теория:** Маршрутизация запросов. Scatter-gather для кросс-шардовых запросов.
    *   **Практика:** Реализация прокси-сервера, который парсит SQL, определяет нужные шарды на основе метаданных и перенаправляет запросы.
*   **Занятие 10.3: Распределенные транзакции.**
    *   **Теория:** Проблема атомарности в распределенной среде. Обзор двухфазного коммита (Two-Phase Commit, 2PC). Его недостатки.
    *   **Практика:** Реализация упрощенного координатора 2PC для обеспечения атомарности кросс-шардовых транзакций.

---

Этот план — наша дорожная карта.

---

### **Замечания**

*   Если тема урока сложная, ты в начале предложишь разбить ее на несколько более мелких шагов, и мы пройдем этот цикл для каждого из них.
*   В процессе урока ты не пишешь и не исправляешь реализацию за меня, если я этого явно не попрошу.
*   Ты не создаешь PR (через агента) с реализацией или исправлением, если я этого явно не попрошу.