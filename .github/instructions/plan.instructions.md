---
applyTo: '**'
---
### **Итоговый План Курса: "Создание High-Performance СУБД на Go с нуля"**

**Главная цель:** Разработать с нуля расширяемую, распределенную реляционную СУБД на Go, поддерживающую SQL, кастомные типы данных и индексов, cost-based оптимизатор, два вида контроля параллелизма (2PL и MVCC/SSI), репликацию и шардирование, получив при этом глубокое понимание внутреннего устройства баз данных.

---

#### **Модуль 0: Фундамент и "Hello, World"**

*   **Цель:** Заложить архитектурный каркас и получить первый работающий прототип.
*   **Занятие 0.1: Введение и настройка проекта.**
    *   **Теория:** Обзор архитектуры СУБД (Parser, Optimizer, Executor, Storage Engine).
    *   **Практика:** Настройка Go-модуля. Создание структуры каталогов (`cmd`, `internal/storage`, `internal/sql`). Написание `main.go`.
*   **Занятие 0.2: Абстракция хранилища и REPL.**
    *   **Теория:** Важность программирования через интерфейсы. Определение "контракта" для нашего движка хранения (`type Engine interface`).
    *   **Практика:** Реализация простейшего `InMemoryKV` на `map[string][]byte`. Создание REPL (Read-Eval-Print Loop) для взаимодействия с ним. Получаем первую "психологическую победу".

---

#### **Модуль 1: Менеджер Хранения (The Storage Engine)**

*   **Ключевая веха:** Научиться эффективно и гибко работать с диском.
*   **Занятие 1.1: Абстракция дискового хранилища.**
    *   **Теория:** Концепция страниц (Pages). Проектирование интерфейса `PageFile` для абстрагирования от конкретной реализации файлового хранилища (один файл, несколько файлов).
    *   **Практика:** Реализация `DiskManager` как основной реализации интерфейса `PageFile` для чтения/записи страниц в единый файл БД.
*   **Занятие 1.2: Пул буферов (Buffer Pool).**
    *   **Теория:** Кэширование страниц в памяти для минимизации I/O. "Грязные" страницы.
    *   **Практика:** Реализация `BufferPoolManager`, который работает с `PageFile` и предоставляет верхним уровням абстракцию страниц в памяти (`FetchPage`, `UnpinPage`, `FlushAllPages`).
*   **Занятие 1.3: Политики вытеснения страниц.**
    *   **Теория:** Алгоритмы LRU и Clock/Second Chance для управления кэшем.
    *   **Практика:** Реализация политики вытеснения Clock для `BufferPoolManager`.

---

#### **Модуль 2: Структура Данных на Диске**

*   **Ключевая веха:** Научиться хранить записи (кортежи) в таблицах, поддерживая расширяемые типы данных.
*   **Занятие 2.1: Страницы с записями (Slotted Pages).**
    *   **Теория:** Формат `Slotted Page` для хранения записей переменной длины.
    *   **Практика:** Реализация `Page` с методами `InsertTuple`, `GetTuple`, `UpdateTuple`.
*   **Занятие 2.2: Представление кортежей и типы данных.**
    *   **Теория:** Проектирование системы типов. Интерфейс `Type` (`Serialize`, `Deserialize`, `Compare`).
    *   **Практика:** Реализация базовых типов (`Integer`, `Varchar`). Структура `Tuple`, которая представляет собой набор значений (`Value`), типизированных через `Type`.
*   **Занятие 2.3: Таблицы как Heap-файлы.**
    *   **Теория:** `Heap File` как коллекция страниц, представляющая таблицу.
    *   **Практика:** Создание `TableHeap` и итератора `TableIterator` для сканирования таблиц.
*   **Занятие 2.4: Системный каталог.**
    *   **Теория:** Хранение мета-информации (о таблицах, колонках, типах, индексах) внутри самой БД.
    *   **Практика:** Создание "мастер-таблиц" с помощью уже реализованного `TableHeap` для хранения схемы данных.

---

#### **Модуль 3: Индексы**

*   **Ключевая веха:** Реализовать B+Tree как один из видов индексов и заложить архитектуру для добавления новых.
*   **Занятие 3.1: Абстракция индекса.**
    *   **Теория:** Проектирование универсального интерфейса `Index` (`Insert`, `Delete`, `Scan`).
    *   **Практика:** Определение интерфейса `Index` и его интеграция с системным каталогом.
*   **Занятие 3.2: B+Tree — Структура и Поиск.**
    *   **Теория:** Структура B+Tree: внутренние и листовые узлы. Алгоритм поиска.
    *   **Практика:** Реализация `BPlusTree` (удовлетворяющего интерфейсу `Index`) и его страниц (`BPlusTreeInternalPage`, `BPlusTreeLeafPage`). Реализация метода `Search(key)`.
*   **Занятие 3.3: B+Tree — Вставка.**
    *   **Теория:** Алгоритм вставки. Расщепление узлов (split).
    *   **Практика:** Реализация метода `Insert(key, value)`.
*   **Занятие 3.4: B+Tree — Удаление.**
    *   **Теория:** Алгоритм удаления. Слияние (merge) и перераспределение (redistribution).
    *   **Практика:** Реализация метода `Delete(key)`.

---

#### **Модуль 4: Исполнение Запросов (Query Execution)**

*   **Ключевая веха:** Заставить СУБД понимать и выполнять сложные SQL-запросы, включая различные виды соединений (JOIN).
*   **Занятие 4.1:** Парсер SQL и модель "Вулкан".
    *   **Теория:** Превращение SQL в AST. Модель итератора "Вулкан" (`Next()`).
    *   **Практика:** Реализация `SeqScanNode`, `IndexScanNode`, `InsertNode`, `CreateTableNode`.
*   **Занятие 4.2:** Продвинутые операторы.
    *   **Теория:** Операторы `Filter` (`WHERE`), `Projection` (`SELECT a, b`), `Limit`.
    *   **Практика:** Реализация `FilterNode`, `ProjectionNode`, `LimitNode`.
*   **Занятие 4.3:** Агрегации и `GROUP BY`.
    *   **Теория:** Хеш-агрегация для вычисления `COUNT`, `SUM`, `AVG` и т.д.
    *   **Практика:** Реализация узла `HashAggregationNode`.
*   **Занятие 4.4: Простейший Join: Nested Loop Join.**
    *   **Теория:** Алгоритм вложенных циклов. Его простота и ужасающая неэффективность (O(N*M)). Случаи, когда он может быть полезен.
    *   **Практика:** Реализация `NestedLoopJoinNode`, который для каждой строки из левого дочернего узла полностью сканирует правый.
*   **Занятие 4.5: Эффективный Join: Hash Join.**
    *   **Теория:** Алгоритм хеш-соединения для экви-соединений. Фаза построения (build phase) и фаза проверки (probe phase).
    *   **Практика:** Реализация `HashJoinNode`.
*   **Занятие 4.6: Сортировка больших объемов данных: External Sorting.**
    *   **Теория:** Алгоритм внешней сортировки слиянием (External Merge Sort).
    *   **Практика:** Реализация `ExternalSortNode`.
*   **Занятие 4.7: Join для отсортированных данных: Sort-Merge Join.**
    *   **Теория:** Алгоритм соединения слиянием.
    *   **Практика:** Реализация `SortMergeJoinNode`.

---

#### **Модуль 5: Оптимизатор Запросов (Query Optimization)**

*   **Ключевая веха:** Научить СУБД выбирать *эффективный* план выполнения запроса, учитывая разные типы индексов.
*   **Занятие 5.1: Сбор статистики.**
    *   **Теория:** Кардинальность, гистограммы, селективность. Зачем это нужно оптимизатору.
    *   **Практика:** Реализация команды `ANALYZE table`. Создание системных таблиц для хранения статистики.
*   **Занятие 5.2: Простой Cost-Based Optimizer.**
    *   **Теория:** Модель стоимости операторов (I/O + CPU). Сравнение стоимости `SeqScan` vs `IndexScan` для разных типов индексов на основе их свойств.
    *   **Практика:** Расширение планировщика для генерации нескольких физических планов (с использованием разных доступных индексов и видов Join) и выбора самого "дешевого" на основе собранной статистики.

---

#### **Модуль 6: Контроль Параллелизма через Блокировки (2PL)**

*   **Ключевая веха:** Реализовать ACID через классическую двухфазную блокировку.
*   **Занятие 6.1: `TransactionManager` и `LockManager`.**
    *   **Теория:** ACID. Двухфазная блокировка (2PL). Shared (S) и Exclusive (X) блокировки.
    *   **Практика:** Реализация `TransactionManager` и `LockManager`.
*   **Занятие 6.2: Уровни изоляции на блокировках.**
    *   **Теория:** Как 2PL позволяет реализовать `Read Committed` и `Repeatable Read`.
    *   **Практика:** Интеграция `LockManager` в итераторы для реализации этих уровней изоляции.
*   **Занятие 6.3: Обнаружение взаимоблокировок (Deadlock Detection).**
    *   **Теория:** Граф ожидания (`waits-for graph`). Поиск циклов. Выбор "жертвы".
    *   **Практика:** Реализация фонового процесса, который строит граф и прерывает транзакции при обнаружении deadlock.
*   **Занятие 6.4: Журналирование и Восстановление (WAL).**
    *   **Теория:** Write-Ahead Logging. ARIES-стиль (Undo/Redo). Чекпоинты.
    *   **Практика:** Реализация `LogManager`. Написание процедуры восстановления (Recovery).

---

#### **Модуль 7: Продвинутый Контроль Параллелизма (MVCC)**

*   **Ключевая веха:** Реализовать современный, неблокирующий механизм контроля параллелизма.
*   **Занятие 7.1: Основы MVCC.**
    *   **Теория:** Хранение версий записей вместо перезаписи. Структура кортежа с `tx_id_create/delete`. Концепция "снимка" (snapshot).
    *   **Практика:** Модификация структуры кортежа. Реализация `TransactionManager`, управляющего ID транзакций.
*   **Занятие 7.2: Snapshot Isolation (Repeatable Read через MVCC).**
    *   **Теория:** Правила видимости версий для транзакции. Преимущество: читатели не блокируют писателей.
    *   **Практика:** Модификация итераторов для проверки видимости версий на основе "снимка" транзакции.
*   **Занятие 7.3: Serializable Snapshot Isolation (SSI).**
    *   **Теория:** Аномалия "Write Skew". Теория SSI: отслеживание конфликтов "чтение-запись" (`rw-conflicts`) для достижения полной сериализуемости.
    *   **Практика:** Добавление в `TransactionManager` структур для отслеживания чтения/записи. Реализация проверки на `rw-` конфликты при коммите.
*   **Занятие 7.4: Сборка мусора (Vacuum).**
    *   **Теория:** Необходимость удаления "мертвых" версий записей.
    *   **Практика:** Реализация фонового процесса `Vacuum` для очистки устаревших данных.

---

#### **Модуль 8: Репликация (Availability & Read Scaling)**

*   **Ключевая веха:** Обеспечить отказоустойчивость и масштабирование чтения через репликацию.
*   **Занятие 8.1: Master-Slave репликация на основе WAL.**
    *   **Теория:** Потоковая репликация (streaming replication). Синхронный vs. асинхронный режим. Позиция в логе (LSN).
    *   **Практика:** Реализация сетевого протокола для передачи записей WAL от мастера к реплике. Реплика входит в режим "восстановления" и постоянно применяет лог.
*   **Занятие 8.2: Управление репликацией и Failover.**
    *   **Теория:** Процесс "повышения" реплики до нового мастера (promotion). Концепция "кворума". Split-brain.
    *   **Практика:** Добавление команд для управления кластером (`SHOW REPLICATION STATUS`). Реализация (возможно, ручного) механизма failover.

---

#### **Модуль 9: Шардирование (Write Scaling)**

*   **Ключевая веха:** Реализовать горизонтальное масштабирование записи и хранения данных.
*   **Занятие 9.1: Архитектура шардирования.**
    *   **Теория:** Стратегии шардирования (Range-based, Hash-based). Ключ шардирования. Проблема "горячих" шардов.
    *   **Практика:** Проектирование архитектуры: узлы данных (shards), координатор/прокси (query router) и сервер метаданных (metadata server).
*   **Занятие 9.2: Координатор запросов.**
    *   **Теория:** Маршрутизация запросов. Scatter-gather для кросс-шардовых запросов.
    *   **Практика:** Реализация прокси-сервера, который парсит SQL, определяет нужные шарды на основе метаданных и перенаправляет запросы.
*   **Занятие 9.3: Распределенные транзакции.**
    *   **Теория:** Проблема атомарности в распределенной среде. Обзор двухфазного коммита (Two-Phase Commit, 2PC). Его недостатки.
    *   **Практика:** Реализация упрощенного координатора 2PC для обеспечения атомарности кросс-шардовых транзакций.

---

Этот план — наша дорожная карта.

---

### **Как мы будем работать**

1.  **Начало занятия:** Я объявляю тему и цели (например, "Сегодня мы заложим основу для работы с диском, создав `DiskManager`").
2.  **Теория:** Я даю краткую, но емкую теоретическую справку. Почему это важно, какие есть подходы, какие компромиссы. Могу ссылаться на литературу.
3.  **Задание (Совместное проектирование):** Вместо того чтобы давать тебе готовое ТЗ, мы спроектируем его вместе. Я начну диалог с наводящих вопросов:
    *   "Какие основные операции должен выполнять компонент, отвечающий за чтение и запись страниц с диска?"
    *   "Как бы ты назвал интерфейс для такого компонента и какие методы в нем бы определил?"
    *   "О каких пограничных случаях или ошибках нам стоит подумать сразу?"
    Твоя задача — размышлять и предлагать идеи. Вместе мы придем к четкому определению интерфейса и его контракта.
4.  **План тестов (Стратегия):** После того как мы определились с интерфейсом, мы переходим к тестированию. Я задам направление:
    *   "Итак, у нас есть метод `WritePage`. Какие сценарии нам нужно проверить, чтобы быть уверенными, что он работает корректно?"
    Ты предлагаешь конкретные тест-кейсы: "Нужно проверить успешную запись, запись по тому же смещению (перезапись), попытку записи в закрытый файл, обработку ошибок диска...". Мы обсуждаем и финализируем список тестов.
5.  **Твоя реализация:** Ты пишешь тесты и код в своем репозитории на GitHub и даешь мне знать, когда готов к ревью
6.  **Ревью:** Я смотрю твой код и тесты. Моя обратная связь будет в форме вопросов, побуждающих к размышлению:
    *   "Я вижу, ты использовал здесь `sync.Mutex`. А что, если несколько горутин захотят одновременно читать? Не будет ли это слишком строгим ограничением?"
    *   "Этот тест проверяет счастливый путь. А как мы можем убедиться, что система поведет себя предсказуемо, если диск внезапно переполнится?"
    *   "Интересное решение. А какие у него могут быть недостатки при очень большом файле базы данных?"
7.  **Итерация:** Ты анализируешь вопросы, вносишь исправления и улучшения. Мы повторяем этот цикл, пока не достигнем результата, которым оба довольны.
8.  **Завершение:** Занятие считается оконченным. Код с тестами находится в основной ветке, и мы готовы к следующему шагу.

**Замечание:** Если тема урока сложная, я в начале предложу разбить ее на несколько более мелких шагов, и мы пройдем этот цикл для каждого из них.